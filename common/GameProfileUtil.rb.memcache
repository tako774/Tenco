require 'db'
require 'cache'

class GameProfileUtil
	VERSION = 'v0.02'

	# ゲーム内プロファイルごとのレート推定算出
	# <引数>
	# names    : （必須）ゲーム内プロファイル名（配列可）（複数要素の場合、複数プロファイル名を使う同一プレイヤーとみなす）
	# game_id  : （必須）対象ゲームID
	# type1_ids : （任意）対象キャラID（配列可）、未指定の場合は全キャラクターについて推定
	# <戻り値>
	# { type1_id => {:track_record_counts => track_record_counts, :log_likelihood => { rating => log_likelihood }] }
	def self.estimate_rating (names, game_id, type1_ids = [])
		# 戻り値
		estimations = {} 
		
		# レート候補
		rates = [
			 900.0,  950.0,
			1000.0,	1050.0,
			1100.0, 1150.0,
			1200.0,	1250.0,
			1300.0, 1350.0,
			1400.0, 1450.0,
			1500.0, 1550.0,
			1600.0, 1650.0,
			1700.0, 1750.0,
			1800.0, 1850.0,
			1900.0, 1950.0,
			2000.0, 2050.0,
			2100.0, 2150.0,
			2200.0, 2250.0,
			2300.0, 2350.0,
			2400.0, 2450.0,
			2500.0, 2550.0,
			2600.0, 2650.0,
			2700.0
		]
		# 対戦結果
		track_records = []
		track_record_ids = []
	
		if names.class != Array then
			names = [names.to_s]
		end
		
		if !type1_ids.nil? && type1_ids.class != Array then
			type_ids = [type1_ids.to_i]
		end
		
		# DB接続取得
		db = DB.getInstance()
		# キャッシュ取得
		cache = Cache.instance
				
		# 対戦結果データ取得
		require 'Game'
		res_game = db.exec(<<-"SQL")
			SELECT
			  name
			FROM
			  games
			WHERE
			  id = #{game_id.to_i}
		SQL
		
		if res_game.num_tuples >= 1 then
		
			# type1 が指定無しの時は、全type1_idを対象にする
			if type1_ids.nil? || type1_ids.length == 0 then
				res = db.exec(<<-"SQL")
				  SELECT
					type1_id
				  FROM
					game_type1s gt
				  WHERE
					gt.game_id = #{game_id.to_i}			
				SQL
				
				res.each do |r|
				  type1_ids << r[0].to_i
				end
				
				res.clear
			end
			
			# type1_id がみつからない場合は結果なしで返す
			if (type1_ids.nil? || type1_ids.length == 0) then
				return estimations
			end
			
			# 各player2_name、player2_type1_id の track_record_id を取得
			require 'TrackRecordDao'
			trd = TrackRecordDao.new
			names.each do |name|
				type1_ids.each do |type1_id|
					track_record_ids += trd.get_ids_by_game_p2name_p2type1(game_id, name, type1_id)
				end
			end
			
			# track_record_id が一つもみつからない場合は結果なしで返す
			if (track_record_ids.length == 0) then
				return estimations
			end
			
			require 'TrackRecordRate'
			
			sql = <<-"SQL"
				SELECT
				  t.player1_points,
				  t.player2_points,
				  t.player2_type1_id,
				  gar.rating
				FROM
				  game_account_ratings gar,
				  track_records t
				WHERE
				  t.id in (#{(track_record_ids.map { |id| id.to_i }).join(", ")})
				  AND gar.game_id = #{game_id.to_i}
				  AND gar.account_id = t.player1_account_id
				  AND gar.type1_id = t.player1_type1_id
				  AND gar.ratings_deviation < 100
				SQL
			
			File.open("/tmp/test", "ab") do |io|
				io.puts sql
			end
			
			res = db.exec(<<-"SQL")
				SELECT
				  t.player1_points,
				  t.player2_points,
				  t.player2_type1_id,
				  gar.rating
				FROM
				  game_account_ratings gar,
				  track_records t
				WHERE
				  t.id in (#{(track_record_ids.map { |id| id.to_i }).join(", ")})
				  AND gar.game_id = #{game_id.to_i}
				  AND gar.account_id = t.player1_account_id
				  AND gar.type1_id = t.player1_type1_id
				  AND gar.ratings_deviation < 100
				SQL
				
			res.each do |r|
				t = TrackRecordRate.new
				# 高速化のためインスタンス名直接指定
				t.player1_points = r[0].to_i
				t.player2_points = r[1].to_i
				t.player2_type1_id = r[2].to_i
				t.rating = r[3].to_f
#			res.num_fields.times do |i|
#				t.instance_variable_set("@#{res.fields[i]}", r[i])
#			end
				track_records << t
			end
			res.clear
					
			
			# 対戦結果が取得できたときはレート推定
			if track_records.length > 0 then
							
				# 発生時間順にレート計算
				track_records.each do |t|
					type1_id = t.player2_type1_id.to_i
					
					# 推定情報初期化
					unless estimations[type1_id]
						estimations[type1_id] ||= {
							:track_record_counts => 0,
							:log_likelihood => {},
						}
						rates.each do |rate|
							estimations[type1_id][:log_likelihood][rate] = 0.0
						end
					end
					
					# 対戦数カウント
					estimations[type1_id][:track_record_counts] += 1
					
					# Player2 取得ポイント
					point = (1.0 + (t.player2_points.to_i <=> t.player1_points.to_i)) * 0.5
					
					# レートごとの尤度計算
					rates.each do |rate|
						# 期待勝率
						p_win = 1.0 / (1.0 + 10.0 ** ((t.rating - rate) / 400.0))
						# 発生尤度加算
						if point == 1
							estimations[type1_id][:log_likelihood][rate] += Math.log(p_win)
						elsif point == 0
							estimations[type1_id][:log_likelihood][rate] += Math.log(1 - p_win)
						end
					end
					
				end
				
				# 尤度のもっとも高いレートを記録
				estimations.each do |type1_id, est|
					type1_log_likelihood = est[:log_likelihood]
					array = type1_log_likelihood.to_a.sort do |a, b|
						b[1] <=> a[1]
					end
					if array[0][1] <= -10
						est[:rating] = array[0][0]
					else
						est[:rating] = nil
					end
				end
				
			end	
		end
		
		return estimations
	end
end
